-- Create tables
create table if not exists profiles (
  id uuid primary key references auth.users on delete cascade,
  created_at timestamp with time zone default now()
);

create table if not exists novels (
  id bigint generated by default as identity primary key,
  title text not null,
  is_public boolean default true,
  created_by uuid references auth.users(id),
  created_at timestamp with time zone default now()
);

create table if not exists chapters (
  id bigint generated by default as identity primary key,
  novel_id bigint references novels(id) on delete cascade,
  number int not null,
  title text,
  content text,
  unique(novel_id, number)
);

create table if not exists translations (
  id bigint generated by default as identity primary key,
  chapter_id bigint references chapters(id) on delete cascade,
  english text,
  notes jsonb default '[]'::jsonb,
  unique(chapter_id)
);

create table if not exists glossary (
  id bigint generated by default as identity primary key,
  novel_id bigint references novels(id) on delete cascade,
  term_zh text,
  term_en text,
  unique(novel_id, term_zh)
);

-- Enable Row Level Security (RLS)
alter table novels enable row level security;
create policy "public can read" on novels for select using ( is_public = true );
create policy "owner can write" on novels for all using ( auth.uid() = created_by ) with check ( auth.uid() = created_by );

alter table chapters enable row level security;
create policy "public read via novel" on chapters for select using (
  exists(select 1 from novels n where n.id = chapters.novel_id and n.is_public)
);
create policy "owner write via novel" on chapters for all using (
  exists(select 1 from novels n where n.id = chapters.novel_id and n.created_by = auth.uid())
) with check (
  exists(select 1 from novels n where n.id = chapters.novel_id and n.created_by = auth.uid())
);

alter table translations enable row level security;
create policy "public read via chapter" on translations for select using (
  exists(select 1 from chapters c join novels n on n.id=c.novel_id where c.id=translations.chapter_id and n.is_public)
);
create policy "owner write via chapter" on translations for all using (
  exists(select 1 from chapters c join novels n on n.id=c.novel_id where c.id=translations.chapter_id and n.created_by = auth.uid())
) with check (
  exists(select 1 from chapters c join novels n on n.id=c.novel_id where c.id=translations.chapter_id and n.created_by = auth.uid())
);

alter table glossary enable row level security;
create policy "public read via novel" on glossary for select using (
  exists(select 1 from novels n where n.id = glossary.novel_id and n.is_public)
);
create policy "owner write via novel" on glossary for all using (
  exists(select 1 from novels n where n.id = glossary.novel_id and n.created_by = auth.uid())
) with check (
  exists(select 1 from novels n where n.id = glossary.novel_id and n.created_by = auth.uid())
);

-- Trigger: create profile when user signs up
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles(id) values (new.id);
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created after insert on auth.users for each row execute procedure public.handle_new_user(); 